# 그리디 알고리즘(탐욕법)(Greedy)

## 그리디 알고리즘(탑욕법)이란?

**`그리디(탐욕법)`** : `탐욕적` : 현재 상황에서 지금 당장 좋은 것만 고르는 방법 : **매 순간 가장 좋아 보이는 것을 선택하는 알고리즘**
- **현재의 선택이 나중에 미칠 영향에 대해서는 고민하지 않는다.**

## 특징

1. 사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형
2. 보통 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력 즉, 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.
    - **특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다!!**
3. **그리디 알고리즘**은 **`기준`** 에 따라 **좋은 것을 선택하는 알고리즘**
    - 문제에서 `가장 큰 순서대로` , `가장 작은 순서대로` 같은 기준을 문제에서 알게 모르게 제시한다.
    - 대체로 이러한 문제들은 **`정렬(sort)`** 알고리즘을 사용했을 때 만족시킬 수 있다. 
4. 그리디 알고리즘 문제는 자주 정렬 알고리즘과 같이 출제된다.

## 예시 문제

1. 거스름돈

### 문제

당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원,100원,50원,10원짜리 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야할 동전의 최소 개수를 구하라. 단 N은 항상 10의 배수이다.

### 코드

```c++
#include <iostream>

using namespace std;

int N, cnt;
int coins[] = { 500, 100, 50, 10 };

int main() {
	cin >> N;

	for (int coin : coins) {
		cnt += N / coin;
		N %= coin;
	}

	cout << cnt << '\n';

	return 0;
}
```

### 풀이

`아이디어` : **가장 큰 화폐부터** 돈을 거슬러 준다.

n의 값을 지정하고, 화폐를 큰 단위부터 순서대로 배열 지정

cnt에 동전 개수를 저장하고, n에는 남은 동전을 저장

화폐의 종류만큼 반복을 수행한다. 화폐의 종류가 K개라고 할 때, `시간 복잡도` 는 **O(K)** 가 된다.

### 그리디 알고리즘의 정당성

그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토해야 한다.

거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 **`가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.`**

EX) N이 800원이고, 동전들이 500, 400, 100원이면 문제가 생긴다.
(500 + 100 + 100 + 100) < (400 + 400)

다시말해, 이 문제에서는 큰 단위가 작은 단위의 배수이므로, `가장 큰 단위의 회폐부터 가장 작은 단위의 화폐까지 차례대로 확인하여 거슬러 주는 작업만을 수행하면 된다` 라는 아이디어가 정당한 것이다.

 **대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 한다.**  

실제로 거스름돈 문제에서 **동전(화폐)의 단위가 서로 배수 형태가 아니라, 무작위로 주어진 경우** 에는 그리디 알고리즘으로 문제를 해결할 수 없다. 화폐의 단위가 무작위로 주어진 문제는 `다이나믹 프로그래밍(dp)` 으로 해결해야 한다.

어떤 코딩테스트를 만났을 때, 바로 문제 유형을 파악하기 어렵다면 그리디 알고리즘을 의심하고, 문제를 해결할 수 있는 탐욕적인 해결 방법이 존재하는지 고민해보자. 만약 오랜 시간을 고민해도 그리디 알고리즘으로 해결방법을 찾을 수 없다면, 그때는 다이나킥 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결할 수 있는지를 재차 고민해보는 것도 방법이다.

2. 큰 수의 법칙

### 문제

동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다.
배열의 크기 N, 숫자가 더해지는 횟수 M, K가 주어질 때 결과를 출력해라.

### 입력 조건

- 첫째 줄에 N(2 <= N <= 1000), M(1 <= M <= 10,000), K(1 <= K <= 10,000)의 자연수, 자연수는 공백으로 구분
- K <= M
- 둘째 줄에 N개의 자연수가 주어지고, 공백 구분(1 <= 자연수 <= 10,000)

### 출력 조건

첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

### 입출력 예시

```json
5 8 3
2 4 5 4 6

46
```

### 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int N, M, K, cnt, answer;
vector<int> nums;

void solution1();
void solution2();

int main() {
	cin >> N >> M >> K;

	nums.resize(N, 0);

	for (int i = 0; i < N; ++i) {
		cin >> nums[i];
	}

	sort(nums.rbegin(), nums.rend());

	int first = nums[0], second = nums[1];

    // solution1();
	solution2();

	cout << answer << '\n';

	return 0;
}

void solution1() {
    while(true) {
        for(int i = 0; i < K; ++i) {
            if(M == 0) {
                break;
            }
            answer += first;
            --M;
        }

        if(M == 0) {
            break;
        }

        answer += second;
        --M;
    }

    return;
}

void solution2() {
    cnt = (M / (K + 1)) * K;
	cnt += (M % (K + 1));

	answer += cnt * first;
	answer += (M - cnt) * second;

    return;
}
```

### 풀이

입력값 중에서 가장 큰 수와 두 번째로 큰 수만 저장한다. 연속으로 더할 수 있는 횟수는 최대 K번이므로 `가장 큰 수를 K번 더하고 두 번째로 큰 수를 한 번 더하는 연산` 을 반복한다.

다만, M의 크기가 100억 이상으로 크기가 커진다면 반복문의 사용은 시간 초과 판정을 받을 것이므로, 반복되는 수열에 대해서 규칙을 파악한다.

위의 예시에서는 수열 {6, 6, 6, 5}가 2번 반복되는데, 이는 M / (K+1)번 반복되는 것이다. (8/4=2)

가장 큰 수는 M이 (K + 1)로 나누어 떨어지면, (M / (K+1)) * K 번 반복되고, 나누어 떨어지지 않으면 M % (K + 1)번 더 반복된다.

가장 큰 횟수가 더해지는 공식을 계산한다 : `((M / (K+1)) * K) + (M % (K+1))`

3. 숫자 카드 게임

### 문제

N(행)xM(열)개의 카드가 있다. 각 행에서 가장 작은 숫자를 뽑고, 이 작은 숫자들 중 가장 큰 값을 출력한다.

### 입력조건

- 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다.(1<=N, M<=100)
- 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10,000이하의 자연수이다.

### 출력조건

규칙에 따라 뽑은 가장 큰 수

### 코드

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int N, M, answer;
vector<vector<int>> cards;

int main() {
	cin >> N >> M;

	cards.resize(N, vector<int>(M, 0));

	for (int i = 0; i < N; ++i) {
		int Min = 10001;

		for (int j = 0; j < M; ++j) {
			cin >> cards[i][j];
			Min = min(Min, cards[i][j]);
		}

		answer = max(answer, Min);
	}

	cout << answer << '\n';

	return 0;
}
```

### 풀이

**각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수를 찾는다.**

입력 조건에서 입력으로 들어오는 수는 모두 10,000 이하이므로 단순히 배열에서 가장 작은 수를 찾는 기본 문법을 이용하여 각 행에서 가장 작은 수를 찾은 다음 그 수 중에서 가장 큰 수를 찾는 방식으로 문제를 해결할 수 있다.

4. 1이 될 때까지

### 문제

N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램 작성
1. N에서 1을 뺀다.
2. N을 K로 나눈다. (N이 K로 나누어 지는 경우만)

### 입력조건

첫째줄에 N(2 <= N <= 100,000)과 K(2 <= K <= 100,000)가 공백으로 구분되며 각각 자연수로 주어진다. 이떄 입력으로 주어지는 N은 항상 K보다 크거나 같다.

### 출력조건

N을 1로 만드는 연산의 최소 횟수

### 코드

```c++
#include <iostream>
#include <vector>

using namespace std;

int N, K, cnt;
void solution1();
void solution2();

int main() {
	cin >> N >> K;

	//solution1();
	solution2();

	cout << cnt << '\n';

	return 0;
}

void solution1() {
	while(N > 1) {
        if(N % K == 0) {
            N /= K;
            ++cnt;
        }
        else {
            --N;
            ++cnt;
        } 
    }

	return;
}

void solution2() {
	while (true) {
		int target = (N / K) * K;
		cnt += N - target;
		N = target;
		
		if (N < K) {
			break;
		}

		N /= K;
		++cnt;
	}

	cnt += N - 1;
}
```

### 풀이

주어진 N에 대하여 `최대한 많이 나누기` 를 수행한다.

N이 100억 이상의 큰 수가 되는 경우를 가정했을 때에도 빠르게 동작하려면, **N이 K의 배수가 되도록 효율적으로 한 번에 빼는 방식으로** 해야한다.